{"version":3,"file":"frontpage-DVOj8LVl.js","sources":["../../node_modules/powerglitch/lib/src/index.js","../../assets/js/glitch.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PowerGlitch = exports.mergeOptions = void 0;\n/**\n * Get best-looking default options for most elements for a given playMode.\n */\nconst getDefaultOptions = (playMode = 'always') => {\n    return {\n        playMode,\n        createContainers: true,\n        hideOverflow: false,\n        timing: playMode === 'always' ? { duration: 2 * 1000, iterations: Infinity } : { duration: 250, iterations: 1 },\n        glitchTimeSpan: playMode === 'always' ? { start: 0.5, end: 0.7 } : { start: 0, end: 1, },\n        shake: {\n            velocity: 15,\n            amplitudeX: 0.2,\n            amplitudeY: 0.2,\n        },\n        slice: playMode === 'click' ? {\n            count: 15,\n            velocity: 20,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        } : {\n            count: 6,\n            velocity: 15,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        },\n        pulse: false,\n    };\n};\n/**\n * Glitch factor function, returns a value between 0 and 1 telling how much the animation should glitch at a given stepPct.\n */\nconst getGlitchFactor = (options, stepPct) => {\n    if (!options.glitchTimeSpan) {\n        return 1;\n    }\n    const glitchStart = options.glitchTimeSpan.start;\n    const glitchEnd = options.glitchTimeSpan.end;\n    if (stepPct < glitchStart || stepPct > glitchEnd) {\n        return 0;\n    }\n    const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;\n    if (stepPct < glitchPeak) {\n        return (stepPct - glitchStart) / (glitchPeak - glitchStart);\n    }\n    else {\n        return (glitchEnd - stepPct) / (glitchEnd - glitchPeak);\n    }\n};\n/**\n * Get a random value between -1 and 1, which biases towards the center if the animation should not glitch at the given `stepPct` moment.\n */\nconst getGlitchRandom = (options, stepPct) => {\n    return (Math.random() - .5) * 2 * getGlitchFactor(options, stepPct);\n};\n/**\n * Get a random rectangle values in % to glitch. Percent values are between 0 and 100. Returns the rectangle as a CSS polygon.\n * @param minHeight Minimum height of the rectangle in percent, between 0 and 1.\n * @param maxHeight Maximum height of the rectangle in percent, between 0 and 1.\n * @param minWidth Minimum width of the rectangle in percent, between 0 and 1.\n * @param maxWidth Maximum width of the rectangle in percent, between 0 and 1.\n */\nconst getRandomRectanglePolygonCss = ({ minHeight, maxHeight, minWidth, maxWidth }) => {\n    const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;\n    const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;\n    // Put this rectangle somewhere in the container so that it does not go out of the screen.\n    const top = Math.floor(Math.random() * (100 - height));\n    const left = Math.floor(Math.random() * (100 - width));\n    const topRight = `${left + width}% ${top}%`;\n    const bottomRight = `${left + width}% ${top + height}%`;\n    const bottomLeft = `${left}% ${top + height}%`;\n    const topLeft = `${left}% ${top}%`;\n    return `polygon(${topRight},${bottomRight},${bottomLeft},${topLeft})`;\n};\n/**\n * Generate a slice layer, slicing part of the element and moving it somwhere else.\n * @param options\n */\nconst generateGlitchSliceLayer = (options) => {\n    const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        if (getGlitchFactor(options, index / stepCount) === 0) {\n            steps.push({\n                opacity: '0',\n                transform: 'none',\n                clipPath: 'unset',\n            });\n            continue;\n        }\n        const translateX = getGlitchRandom(options, index / stepCount) * 30;\n        const styles = {\n            opacity: '1',\n            transform: `translate3d(${translateX}%,0,0)`,\n            clipPath: getRandomRectanglePolygonCss({ minHeight: options.slice.minHeight, maxHeight: options.slice.maxHeight, minWidth: 1, maxWidth: 1 }),\n        };\n        if (options.slice.hueRotate) {\n            styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;\n        }\n        steps.push(styles);\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate a pulse layer, a single transparent and growing layer.\n * @param options\n */\nconst generateGlitchPulseLayer = (options) => {\n    return !options.pulse ? null : {\n        steps: [\n            { transform: 'scale(1)', opacity: '1', },\n            { transform: `scale(${options.pulse.scale})`, opacity: '0', },\n        ],\n        timing: Object.assign(Object.assign({}, options.timing), { delay: (options.glitchTimeSpan ? options.glitchTimeSpan.start : 0) * options.timing.duration, easing: 'ease-in-out' }),\n    };\n};\n/**\n * Generate the base layer, which may or may not shake depending on the options.\n * @param options\n */\nconst generateBaseLayer = (options) => {\n    if (!options.shake) {\n        return { steps: [], timing: {} };\n    }\n    const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;\n        const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;\n        steps.push({\n            transform: `translate3d(${translateX}%,${translateY}%,0)`,\n        });\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate the layers that deterministically define a glitch animation for the specified options.\n */\nconst generateLayers = (options) => [\n    generateBaseLayer(options),\n    generateGlitchPulseLayer(options),\n    ...Array.from({ length: options.slice.count }).map(() => generateGlitchSliceLayer(options)),\n].filter(entry => entry !== null);\n/**\n* Performs a deep merge of option objects and returns new object. Does not modify\n* objects (immutable) and will ignore arrays.\n* @param objects - Objects to merge\n* @returns New object with merged key/values\n*/\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst mergeOptions = (...objects) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isObject = (obj) => obj && typeof obj === 'object';\n    return objects.reduce((prev, obj) => {\n        Object.keys(obj)\n            .forEach(key => {\n            if (isObject(prev[key]) && isObject(obj[key])) {\n                prev[key] = (0, exports.mergeOptions)(prev[key], obj[key]);\n            }\n            else if (obj[key] !== undefined) {\n                prev[key] = obj[key];\n            }\n        });\n        return prev;\n    }, {});\n};\nexports.mergeOptions = mergeOptions;\n/**\n * Prepare the DOM to set up the glitch effect.\n * @remarks\n * Depending on the element state:\n *  - Whether it was glitched before or not,\n *  - Whether current element display attributes\n *  - Whether options.createContainers is true/false\n * The top-level container and layer containers might be different objects and might need to be created.\n * @param element\n * @param options\n * @returns\n */\nconst prepareGlitchElement = (element, options) => {\n    var _a, _b;\n    // If not creating the containers\n    if (!options.createContainers) {\n        return {\n            container: element,\n            layersContainer: element,\n            glitched: element.firstElementChild,\n        };\n    }\n    // If first glitch\n    if (!element.dataset.glitched) {\n        // Setup the layer container using grid to stack elements\n        const layersContainer = document.createElement('div');\n        // If current element is an inline element\n        const container = document.createElement('div');\n        if (getComputedStyle(element).getPropertyValue('display').match(/^inline/)) {\n            container.style.display = 'inline-block';\n        }\n        // Add the layers container to the global container\n        container.appendChild(layersContainer);\n        // Replace element with the new container\n        (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(container, element);\n        layersContainer.prepend(element);\n        return {\n            container,\n            layersContainer,\n            glitched: element,\n        };\n    }\n    // Not first glitch, with createContainers=true\n    const layersContainer = element.parentElement;\n    const container = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement;\n    // Remove all glitch layers but keep the first one (which is the original element)\n    while (layersContainer.children.length > 1) {\n        layersContainer.removeChild(layersContainer.children[1]);\n    }\n    // Cancel the animation on the first layer\n    layersContainer.firstElementChild.getAnimations().forEach(animation => animation.cancel());\n    return {\n        container,\n        layersContainer,\n        glitched: element,\n    };\n};\n/**\n * Given a set of computed layers and user options, glitch a given element\n * @param element\n * @param layers\n * @param options\n */\nconst glitchElement = (element, layers, options) => {\n    const { glitched, container, layersContainer } = prepareGlitchElement(element, options);\n    // Force grid display on the layer container\n    layersContainer.style.display = 'grid';\n    // Overflow\n    if (options.hideOverflow) {\n        container.style.overflow = 'hidden';\n    }\n    // If setting HTML manually\n    if (options.html) {\n        glitched.innerHTML = options.html;\n    }\n    // Stack original element too (it is used as the base shaking layer)\n    glitched.style.gridArea = '1/1/-1/-1';\n    // Base layer\n    const baseLayer = glitched.cloneNode(true);\n    baseLayer.dataset.islayer = 'true';\n    // Stack this layer\n    baseLayer.style.gridArea = '1/1/-1/-1';\n    baseLayer.style.userSelect = 'none';\n    baseLayer.style.pointerEvents = 'none';\n    baseLayer.style.opacity = '0';\n    for (let i = 0; i < layers.length - 1; ++i) {\n        const layerDiv = baseLayer.cloneNode(true);\n        layersContainer.appendChild(layerDiv);\n    }\n    // Glitch control functions\n    const startGlitch = () => {\n        layers.forEach((layer, i) => {\n            layersContainer\n                .children[i]\n                .animate(layer.steps, layer.timing);\n        });\n    };\n    const stopGlitch = () => {\n        layers.forEach((_, i) => {\n            layersContainer\n                .children[i]\n                .getAnimations()\n                .forEach(animation => {\n                animation.cancel();\n            });\n        });\n    };\n    // Depending on the selected play mode, orchestrate when to start/stop the glitch\n    container.onmouseenter = null;\n    container.onmouseleave = null;\n    container.onclick = null;\n    switch (options.playMode) {\n        case 'always':\n            startGlitch();\n            break;\n        case 'hover':\n            container.onmouseenter = startGlitch;\n            container.onmouseleave = stopGlitch;\n            break;\n        case 'click':\n            container.onclick = () => { stopGlitch(); startGlitch(); };\n            break;\n    }\n    // Mark the glitched element as glitched for next round\n    element.dataset.glitched = '1';\n    return { container, startGlitch, stopGlitch };\n};\n/**\n * Make a single element glitch.\n * @param elOrSelector What to glitch. Can be a query selector, a list of HTMLElement, an HTMLElement or a NodeList.\n * @param userOptions Optional glitch customization options.\n */\nconst glitch = (elOrSelector = '.powerglitch', userOptions = {}) => {\n    // Fix options with defaults\n    const options = (0, exports.mergeOptions)(getDefaultOptions(userOptions.playMode), userOptions);\n    // Find elements to glitch\n    let elements = [];\n    if (typeof elOrSelector === 'string') {\n        elements = Array.from(document.querySelectorAll(elOrSelector));\n    }\n    else if (elOrSelector instanceof NodeList) {\n        elements = Array.from(elOrSelector);\n    }\n    else if (Array.isArray(elOrSelector)) {\n        elements = elOrSelector;\n    }\n    else if (elOrSelector instanceof HTMLElement) {\n        elements = [elOrSelector];\n    }\n    // Generate all animation layers\n    const layers = generateLayers(options);\n    // Animate each div element\n    const entries = elements\n        /**\n         * When calling glitch(..) multiple times on the same element using query selector, glitch layers will also match the selector.\n         * Only the root-layer (base element) should be glitched, so we ensure we filter out non-root glitch layers.\n         */\n        .filter(element => !element.dataset.islayer)\n        // Each element is glitched using the same layer definition.\n        .map((element) => glitchElement(element, layers, options));\n    // Return list of containers and glitch control functions\n    return {\n        containers: entries.map(entry => entry.container),\n        startGlitch: () => entries.forEach(entry => entry.startGlitch()),\n        stopGlitch: () => entries.forEach(entry => entry.stopGlitch()),\n    };\n};\nexports.PowerGlitch = {\n    glitch,\n    generateLayers,\n    getDefaultOptions,\n};\n","import { PowerGlitch } from 'powerglitch'\n\nPowerGlitch.glitch('.glitch')"],"names":["exports","getDefaultOptions","playMode","getGlitchFactor","options","stepPct","glitchStart","glitchEnd","glitchPeak","getGlitchRandom","getRandomRectanglePolygonCss","minHeight","maxHeight","minWidth","maxWidth","height","width","top","left","topRight","bottomRight","bottomLeft","topLeft","generateGlitchSliceLayer","stepCount","steps","index","styles","generateGlitchPulseLayer","generateBaseLayer","translateX","translateY","generateLayers","entry","mergeOptions","objects","isObject","obj","prev","key","prepareGlitchElement","element","_a","_b","layersContainer","container","animation","glitchElement","layers","glitched","baseLayer","i","layerDiv","startGlitch","layer","stopGlitch","_","glitch","elOrSelector","userOptions","elements","entries","PowerGlitch"],"mappings":"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","x_google_ignoreList":[0]}